spring:
  application:
    name: ${SPRING_APPLICATION_NAME:worli-chattermouth}
  data:
    mongodb:
      host: ${MONGODB_HOST:localhost}
      port: ${MONGODB_PORT:27017}
      database: ${MONGODB_DATABASE:worli}
  mail:
    host: ${MAIL_HOST:smtp.gmail.com}
    port: ${MAIL_PORT:587}
    username: ${MAIL_USERNAME:paragbhardwajcs@gmail.com}
    password: ${MAIL_PASSWORD:shcr vuqc kryw vhwc}
    properties:
      mail:
        smtp:
          auth: ${MAIL_SMTP_AUTH:true}
          starttls:
            enable: ${MAIL_SMTP_STARTTLS_ENABLE:true}
            required: ${MAIL_SMTP_STARTTLS_REQUIRED:true}
          connectiontimeout: ${MAIL_SMTP_CONNECTION_TIMEOUT:5000}
          timeout: ${MAIL_SMTP_TIMEOUT:5000}
          writetimeout: ${MAIL_SMTP_WRITE_TIMEOUT:5000}
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}  # Kafka broker address, defaults to localhost if not set
    consumer:
      group-id: ${KAFKA_CONSUMER_GROUP_ID:my-group-id}             # Consumer group id, defaults to 'my-group-id' if not set
      auto-offset-reset: ${KAFKA_CONSUMER_AUTO_OFFSET_RESET:earliest}  # Start reading from the earliest, defaults to 'earliest'
      key-deserializer: ${KAFKA_CONSUMER_KEY_DESERIALIZER:org.apache.kafka.common.serialization.StringDeserializer}
      value-deserializer: ${KAFKA_CONSUMER_VALUE_DESERIALIZER:org.apache.kafka.common.serialization.StringDeserializer}
    producer:
      key-serializer: ${KAFKA_PRODUCER_KEY_SERIALIZER:org.apache.kafka.common.serialization.StringSerializer}
      value-serializer: ${KAFKA_PRODUCER_VALUE_SERIALIZER:org.apache.kafka.common.serialization.StringSerializer}

server:
  port: ${SERVER_PORT:8080}


http:
  pool-properties:
    llm-conversational-pool-config:
      maxTotal: ${LLM_CONVERSATIONAL_HTTP_POOL_MAX_TOTAL:100}
      defaultMaxPerRoute: ${LLM_CONVERSATIONAL_HTTP_POOL_DEFAULT_MAX_PER_ROUTE:100}
      connectionTimeout: ${LLM_CONVERSATIONAL_HTTP_POOL_CONNECTION_TIMEOUT:10000}
      socketTimeout: ${LLM_CONVERSATIONAL_HTTP_POOL_SOCKET_TIMEOUT:10000}
      requestTimeout: ${LLM_CONVERSATIONAL_HTTP_POOL_REQUEST_TIMEOUT:10000}
    google-get-token-pool-config:
      maxTotal: ${GOOGLE_GET_TOKEN_HTTP_POOL_MAX_TOTAL:100}
      defaultMaxPerRoute: ${GOOGLE_GET_TOKEN_HTTP_POOL_DEFAULT_MAX_PER_ROUTE:100}
      connectionTimeout: ${GOOGLE_GET_TOKEN_HTTP_POOL_CONNECTION_TIMEOUT:10000}
      socketTimeout: ${GOOGLE_GET_TOKEN_HTTP_POOL_SOCKET_TIMEOUT:10000}
      requestTimeout: ${GOOGLE_GET_TOKEN_HTTP_POOL_REQUEST_TIMEOUT:10000}
    google-get-profile-data-pool-config:
      maxTotal: ${GOOGLE_GET_PROFILE_HTTP_POOL_MAX_TOTAL:100}
      defaultMaxPerRoute: ${GOOGLE_GET_PROFILE_HTTP_POOL_DEFAULT_MAX_PER_ROUTE:100}
      connectionTimeout: ${GOOGLE_GET_PROFILE_HTTP_POOL_CONNECTION_TIMEOUT:10000}
      socketTimeout: ${GOOGLE_GET_PROFILE_HTTP_POOL_SOCKET_TIMEOUT:10000}
      requestTimeout: ${GOOGLE_GET_PROFILE_HTTP_POOL_REQUEST_TIMEOUT:10000}

service:
  config:
    llm-conversational-config:
      url: ${LLM_CONVERSATIONAL_SERVICE_URL:https://api.openai.com/v1/chat/completions}
    google-get-token-config:
      url: ${GOOGLE_GET_TOKEN_API_URL:https://oauth2.googleapis.com/token}
    google-get-profile-config:
      url: ${GOOGLE_GET_PROFILE_CONFIG_URL:https://www.googleapis.com/oauth2/v2/userinfo}

allowed-origins: ${ALLOWED_ORIGINS:*}

mail:
  smtp:
    user: paragbhardwajcs@gmail.com

google:
  client:
    id: ${GOOGLE_CLIENT_ID}
    secret: ${GOOGLE_CLIENT_SECRET}
  redirect-uri: ${GOOGLE_REDIRECT_URI:http://localhost:3000/homepage}
  project-id: ${GOOGLE_PROJECT_ID:coherent-ascent-436020-n2}
  subscription-id: ${GOOGLE_GMAIL_SUBSCRIPTION_ID:gmail-subscription}

openai:
  authorization-value: ${OPENAI_AUTHORIZATION_VALUE}

receiver-worli:
  email: ${RECEIVER_WORLI_EMAIL:paragbhardwajcs@gmail.com}
  email-password: ${RECEIVER_WORLI_PASSWORD}
  activated: ${RECEIVER_WORLI_ACTIVATED}

conversational-model:
  prompt: "I have received an email from a user, and I will provide the chat history (if any) as a numbered list for the user. Please use the chat history to build context from past conversations, along with the response you give. Additionally, I need to extract specific information and classify the intent based on the content.\n\nNOTE: ONLY PROVIDE A JSON BODY IN OUTPUT.\nPLEASE MAKE USE OF chat_history FOR CONTEXT BUILDING OF PAST CONVERSATIONS.\n\nEmail Received: %s\n\nChat History (If any): %s (Please reference this list when determining context and intent.)\n\nInformation to Extract:\n- from_email: (Sender's email address)\n- to_email: (Recipient’s email, cannot be 'Worli')\n- meeting_time: (Time for the new meeting, formatted as HH:MM)\n- cancel_meeting_date: (Date of the meeting to be cancelled, formatted as DD/MM/YYYY)\n- new_meeting_date: (Date for the new meeting, formatted as DD/MM/YYYY)\n- agenda: (Meeting agenda)\n- suggested_slots: (Time slots suggested by the sender)\n- deadline_date: (Deadline by when the meeting should be scheduled, formatted as DD/MM/YYYY)\n- from_name: (Sender's name)\n- to_name: (Recipient’s name, cannot be 'Worli')\n- intent: (Intent classification code)\n- from_phone: (Phone number of the sender)\n\nIntent Classification:\n- Schedule a meeting (Code: 1)\n- Cancel (Code: 2)\n- Reschedule a meeting (Code: 3)\n- Irrelevant Intent (Code: 4)\n\nIf any values are missing, return them as 'null.'\n\nAdditional Requirements:\nIf the recipient’s ('to') email address is not present, generate an email to request it. Include the following keys in the JSON response:\n- subject: Email subject (null if follow-up is not needed)\n- body: Email body (null if follow-up is not needed)\n- is_followup: TRUE if a follow-up email is required, otherwise FALSE\n\nNOTE:\nONLY RETURN JSON IN THE OUTPUT.\nPLEASE USE chat_history TO BUILD CONTEXT."

kafka:
  topic:
    email-receiver: ${TOPIC_NAME_EMAIL_RECEIVER:test-topic}
  listener:
    enabled:
      email-receiver: ${EMAIL_RECEIVER_LISTENER_ENABLED}
